<?php

function SeoTags()
{
   ?>
   <title>Поможем гномику собрать звёзды</title>
   <?php
}

function MobiStyle()
{
   ?>
   <link rel="stylesheet" 
      href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
   <link rel="stylesheet" type="text/css" href="Styles/Reset.css">
   <link rel="stylesheet" type="text/css" href="Styles/mobiStyles.css">
   <?php
}

function DescStyle()
{
   ?>
   <link rel="stylesheet" 
      href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
   <link rel="stylesheet" type="text/css" href="Styles/Reset.css">
   <link rel="stylesheet" type="text/css" href="Styles/Styles.css">
   <?php
}

function MobiMarkup()
{
   ?>
   // Скрываем ненужные дивы в мобильной версии
   $('#Heady').css('display','none');
   $('#Footy').css('display','none');
   // Открываем дивы сейчас (то есть после полной загрузки страницы) 
   $('#DriveBottom').css('display','block');
   $('#Main').css('display','block');
   //$('#lList').css('display','block');
   $('body').css('display','block');
   // Центрируем игровое поле
   var aScreenInfo=getScreenInfo(false);  
   var $padleft=Math.floor(((aScreenInfo[6]-gWidth)/2));  
   $('#Play').css('padding-left',$padleft);
   <?php
}

function DescMarkup()
{
   ?>
   // Открываем дивы сейчас (то есть после полной загрузки страницы) 
   $('#Main').css('display','block');
   $('#lList').css('display','block');
   $('body').css('display','block');
   aScreenInfo=getScreenInfo(false);  
   MakeScreenInfo(aScreenInfo);
   setMainWidth('Computer',gWidth,100);
   hh=setPlayHeight('Computer',gHeight,20);
   <?php
}

function Content()
{

/*
http://phaser.io/tutorials/making-your-first-phaser-2-game/index

Порядок функций Phaser, зарезервированные имена и специальные применения
https://www.html5gamedevs.com/topic/1372-phaser-function-order-reserved-names-and-special-uses/

Форумы Фазера
https://www.html5gamedevs.com/

Примеры Фазера
http://phaser.io/examples
*/ 

 /*
<script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
<script src="js/phaser.min.js"></script>
<script src="js/phaser242.min.js"></script>
*/ 
?>

<script type="text/javascript">
// Создаем экземпляр объекта Phaser.Game:
// Первые два параметра - это ширина и высота элемента холста, который будет 
// создан Phaser. В этом случае 800 х 600 пикселей. Ваш игровой мир может быть 
// любого размера, который вам нравится, но это разрешение, в котором будет 
// отображаться игра. 
// Третьим параметром может быть либо Phaser.CANVAS, 
// Phaser.WEBGL, либо Phaser.AUTO. Это контекст рендеринга, который вы хотите 
// использовать. Рекомендованным параметром является Phaser.AUTO, который 
// автоматически пытается использовать WebGL, но если браузер или устройство 
// не поддерживает его, он вернется к Canvas.
// Четвертый параметр - пустая строка, это идентификатор элемента DOM, 
// в который вы хотите вставить элемент canvas, который создает Phaser. 
// Поскольку мы оставили это поле пустым, оно будет просто добавлено к телу. 
// Последний параметр - это объект, содержащий четыре ссылки на основные функции
// Phasers.

// Размещаем игру на игровом поле
var game = new Phaser.Game
   (gWidth,gHeight,Phaser.AUTO,'FieldPlay',{ preload:preload,create:create,update:update });

function preload() 
{
   /*  
   Загрузим ресурсы, которые нам нужны для нашей игры: 3 изображения и спрайт.
   Первый параметр, также известный как ключ актива. Эта строка является 
   ссылкой на загруженный ресурс и используется в вашем коде при создании 
   спрайтов. Вы можете использовать любую допустимую строку JavaScript в 
   качестве ключа.
   */
   game.load.image('sky', 'assets/sky.png');
   game.load.image('ground', 'assets/platform.png');
   game.load.image('star', 'assets/star.png');
   game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
}
var player;
var platforms;
var cursors;
var stars;
/*  
// Обеспечиваем подсчет очков. Для этого мы будем использовать объект Phaser.Text. З
// десь мы создаем две новые переменные, одну для хранения фактической оценки 
// и самого текстового объекта
*/
var score = 0;
var scoreText;
var sign=0;

function create() 
{
   /*  
   Мы собираемся использовать физику, поэтому включите систему Arcade Physics
   */
   game.physics.startSystem(Phaser.Physics.ARCADE);
   /*  
   Простой фон для нашей игры
   */ 
   game.add.sprite(0, 0, 'sky');
   // Группа платформ содержит землю и 2 выступа, по которым мы можем прыгнуть:
   // группы действительно мощные. Как следует из их названия, они позволяют 
   // группировать похожие объекты и управлять ими как единым целым. Вы также 
   // можете проверить наличие коллизий между группами, и для этой игры мы будем
   // использовать две разные группы, одна из которых создаётся для платформ -
   // platforms = game.add.group(). Как и со спрайтами, game.add создается наша
   // группа объектов. Мы присваиваем его новой локальной переменной с именем 
   // platforms. Теперь мы можем добавлять объекты в него. Сначала это земля. 
   
   // Это расположено внизу игры и использует загруженное ранее изображение с 
   // земли. Земля масштабируется, чтобы заполнить ширину игры. Наконец, мы 
   // устанавливаем для его immovable свойства значение true. Если бы мы не 
   // сделали этого, земля могла бы двигаться, когда игрок столкнулся с ней
   // (подробнее об этом в разделе «Физика»).

   // С землей на месте мы создаем два небольших уступа, чтобы перейти к той же 
   // технике, что и для земли.
   platforms = game.add.group();
   // Мы включим физику для любого объекта, который создан в этой группе
   platforms.enableBody = true;
   // Здесь мы создаем землю
   var ground = platforms.create(0, game.world.height - 64, 'ground');
   // Масштабируем её по ширине игры (оригинальный спрайт размером 400х32)
   ground.scale.setTo(2, 2);
   // Это останавливает его от падения при прыжке
   ground.body.immovable = true;
   // Теперь давайте создадим два выступа
   var ledge = platforms.create(400, 400, 'ground');
   ledge.body.immovable = true;
   ledge = platforms.create(-150, 250, 'ground');
   ledge.body.immovable = true;

   // Создаем и настраиваем игрока: игрок расположенй на 32 пикселя на 150 
   // пикселей снизу игры. Мы использовать ранее загруженный актив «dude». Если 
   // вы вернетесь к функции предварительной загрузки, то увидите, что «чувак» 
   // был загружен в виде листа спрайта, а не изображения. Это потому, что он 
   // содержит кадры анимации из 9 кадров, 4 для бега влево, 1 для движения 
   // лицом к камере и 4 для бега вправо. Примечание: Phaser поддерживает 
   // переворачивание спрайтов для сохранения на кадрах анимации, но для этого 
   // урока мы оставим его в старом стиле.
   //
   // Мы определяем две анимации, называемые «левая» и «правая». «Левая» 
   // анимация использует кадры 0, 1, 2 и 3 и работает со скоростью 10 кадров 
   // в секунду. Параметр 'true' указывает анимации зацикливаться. Это наш 
   // стандартный цикл выполнения, и мы повторяем его для запуска в 
   // противоположном направлении. С набором анимации мы создаем несколько 
   // физических свойств.
   player = game.add.sprite(32, game.world.height - 150, 'dude');
   
   // Нужно включить физику на плеере: Фазер поддерживает различные физические
   // системы. Он поставляется с физикой аркад, физикой ниндзя и физикой 
   // полного тела P2.JS. Для этого урока мы будем использовать систему Arcade
   // Physics, которая проста и легка, идеально подходит для мобильных браузеров.
   game.physics.arcade.enable(player);
    
   // Физические свойства игрока:  спрайты получают новое свойство тела, которое 
   // является экземпляром ArcadePhysics.Body. Это представляет спрайт как ф
   // изическое тело в движке Phaser Arcade Physics. Объект body обладает 
   // множеством свойств, с которыми мы можем играть. Чтобы симулировать влияние
   // гравитации на спрайт, достаточно просто написать следующее: player.body.gravity.y = 300.
   // Это произвольное значение, но логически, чем выше значение, тем тяжелее 
   // ощущается ваш объект и тем быстрее он падает. Если вы добавите это в свой 
   // код, то увидите, что игрок падает без остановки, полностью игнорируя 
   // созданную ранее площадку. 
   //
   // Причина этого в том, что мы еще не тестируем столкновение между землей 
   // и игроком. Мы уже сказали Фазеру, что наша земля и уступы будут неподвижны. 
   // Если бы мы не сделали этого, когда игрок столкнулся с ними, он остановился 
   // бы на мгновение, и тогда все рухнуло бы. Это потому, что если не указано 
   // иное, наземный спрайт является движущимся физическим объектом (также 
   // известным как динамическое тело), ??и когда игрок ударяет его, результирующая 
   // сила столкновения прикладывается к земле, поэтому оба тела обмениваются 
   // своими скоростями. и земля тоже начинает падать. 
   // Дайте маленькому парню легкий отскок.
   player.body.bounce.y = 0.2;
   player.body.gravity.y = 300;
   player.body.collideWorldBounds = true;
   // Наши две анимации, идущие влево и вправо.
   player.animations.add('left', [0, 1, 2, 3], 10, true);
   player.animations.add('right', [5, 6, 7, 8], 10, true);

   // Давайте бросим капли звезд на сцену и позволим игроку собирать их. Для 
   // этого мы создадим новую группу под названием «звезды» и заполним ее. 
   stars = game.add.group();
   //  We will enable physics for any star that is created in this group
   stars.enableBody = true;
   // Создаём 12 равномерно расположенных звёзд: процесс похож на тот момент,
   // когда мы создали группу платформ. Используя цикл «for» JavaScript, мы 
   // говорим, чтобы создать 12 звезд в нашей игре. У них есть координата x = 
   // i * 70, что означает, что они будут равномерно распределены в сцене на 
   // расстоянии 70 пикселей. Как и в случае с игроком, мы присваиваем им 
   // значение силы тяжести, чтобы они упали, и значение отскока, чтобы они 
   // слегка подпрыгивали при попадании на платформы.
   for (var i = 0; i < 12; i++)
   {
      // Создаем звезду внутри группы 'stars'
      var star = stars.create(i * 70, 0, 'star');
      // Пусть гравитация делает свое дело
      star.body.gravity.y = 300;
      // Это просто дает каждой звезде немного случайное значение отскока:
      // отскок - это значение от 0 (нет отказов вообще) до 1 (полный отскок). 
      // Наши отскок где-то между 0,7 и 0,9. 
      star.body.bounce.y = 0.7 + Math.random() * 0.2;
   }

    // Устанавливаем текстовый объект для подсчета оценок: 16x16 - это координата
    // для отображения текста. «Score: 0» - это строка по умолчанию для отображения, 
    // а следующий объект содержит размер шрифта и цвет заливки. Если не указать,
    // какой шрифт мы будем использовать, браузер будет по умолчанию, 
    // поэтому в Windows это будет Arial. 
    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

    //  Our controls.
    cursors = game.input.keyboard.createCursorKeys();
    
    
    // Выводим ширину окна браузера, толщины полосы прокрутки и высоту окна браузера
    // и код последней нажатой клавиши
    var wb = window.innerWidth||document.documentElement.clientWidth;
    var wcl=document.body.clientWidth;
    var ScrollWidth = wb - wcl;
    var hb = window.innerHeight||document.documentElement.clientHeight;
    sizeText = game.add.text(600,4,'s',{fontSize:'24px',fill:'#000'});
    sizeText.text = wb+' [-'+ScrollWidth+'] * '+hb; //+' ['+onikeyUp+']';
    
    
}

// Функция обновления вызывается ядром игрового цикла каждый кадр. 
// Функция Physics.collide выполняет магию. Он берет два объекта и тесты на 
// столкновение и выполняет разделение против них. В этом случае мы даем ему 
// спрайт игрока и группу платформ. Он достаточно умен, чтобы столкнуться со 
// всеми членами группы, поэтому этот один вызов столкнется с землей и 
// обоими уступами. Результатом является устойчивая платформа.
function update() 
{
   // Чтобы позволить игроку сталкиваться и использовать физические свойства, 
   // нам нужно ввести проверку столкновения в функции обновления:
   // сталкиваем игрока и звезды с платформами
   var hitPlatform = game.physics.arcade.collide(player, platforms);
   // Для того, чтобы звезды не упали сквозь дно игры, проверяем их столкновение 
   // с платформами в нашем цикле обновления
   game.physics.arcade.collide(stars, platforms);
   // Проверяем, совпадает ли игрок со звездой, если да, то передаём их 
   // в функцию collectStar. 
   game.physics.arcade.overlap(player, stars, collectStar, null, this);
   
   // Коллизии это хорошо, но нам действительно нужен игрок, чтобы двигаться.
   // Phaser имеет встроенный менеджер клавиатуры и одно из преимуществ 
   // использования этой небольшой удобной функции: cursors = game.input.keyboard.createCursorKeys();
   // Это заполняет объект курсора четырьмя свойствами: вверх, вниз, влево, 
   // вправо, которые являются экземплярами объектов Phaser.Key. Тогда все, что 
   // нам нужно сделать, это опросить их в нашем цикле обновления:
    
   // Сбросить скорость игроков (задать движение):
   // первое, что мы делаем, это сбрасываем горизонтальную скорость на спрайте. 
   // Затем мы проверяем, нажата ли левая клавиша курсора. Если это так, мы 
   // применяем отрицательную горизонтальную скорость и запускаем «левую» 
   // анимацию бега. Если они удерживают «право», вместо этого мы буквально 
   // делаем наоборот. Очищая скорость и устанавливая ее таким образом, каждый 
   // кадр создает стиль движения «стоп-старт».
   
   // Спрайт игрока будет двигаться только тогда, когда нажата клавиша, и сразу
   // же остановится. Phaser также позволяет вам создавать более сложные 
   // движения, с импульсом и ускорением, но это дает нам эффект, который нам 
   // нужен для этой игры. Последняя часть проверки ключа устанавливает кадр в 
   // 4, если ни одна клавиша не удерживается. Кадр 4 в спрайт-листе - это кадр 
   // игрока, который смотрит на тебя вхолостую.
   player.body.velocity.x = 0;
   // Перемещаем игрока влево
   if ((cursors.left.isDown)||(e_lBu)||(e_lTu))
   {
      player.body.velocity.x = -150;
      player.animations.play('left');
   }
   // Перемещаем игрока вправо
   else if ((cursors.right.isDown)||(e_rBu)||(e_rTu))
   {
      player.body.velocity.x = 150;
      player.animations.play('right');
   }
   else
   {
      // Стоим на месте
      player.animations.stop();
      player.frame = 4;
   }
   
   // Разрешить игроку прыгать, если он касается земли: Курсор вверх - это наша
   // кнопка перехода, и мы проверяем, нажата ли она. Однако мы также проверяем, 
   // касается ли игрок пола, иначе он может прыгнуть, находясь в воздухе. Мы 
   // проверяем переменную hitPlatform просто для того, чтобы убедиться, что 
   // игрок действительно столкнулся с полом, а не что-нибудь еще. Если оба эти 
   // условия выполнены, мы применяем вертикальную скорость 350 пикс / сек. 
   // Игрок автоматически упадет на землю из-за значения гравитации, которое мы
   // к нему применили. 
   if 
   ((cursors.up.isDown && player.body.touching.down && hitPlatform)||
   (e_tBu && player.body.touching.down && hitPlatform)||
   (e_tTu && player.body.touching.down && hitPlatform))
   {
      player.body.velocity.y = -350;
   }
}

function collectStar (player, star) 
{
   // Убираем звезду с экрана
   star.kill();
   // Когда игрок поднимает звезду, его счет увеличивается, а текст обновляется, 
   // чтобы отразить это
   score += 10;
   scoreText.text = 'Score: ' + score;
}
</script>

<?php 
}
